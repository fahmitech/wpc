package compiler

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"net/netip"
	"sort"
	"strings"

	"github.com/fahmitech/wpc/pkg/types"
)

type nftSetDef struct {
	Name     string
	Family   string
	ElemType string
	Flags    []string
	Elements []string
}

type nftRenderContext struct {
	sets map[string]nftSetDef
}

func newNFTRenderContext() *nftRenderContext {
	return &nftRenderContext{
		sets: map[string]nftSetDef{},
	}
}

func normalizeElements(elements []string) []string {
	if len(elements) == 0 {
		return nil
	}
	cp := append([]string(nil), elements...)
	sort.Strings(cp)
	out := make([]string, 0, len(cp))
	var last string
	for i, el := range cp {
		if i == 0 || el != last {
			out = append(out, el)
			last = el
		}
	}
	return out
}

func (c *nftRenderContext) ensureSet(kind string, family string, elemType string, elements []string, flags []string) string {
	normalized := normalizeElements(elements)
	h := sha256.Sum256([]byte(kind + "|" + family + "|" + elemType + "|" + strings.Join(normalized, ",")))
	name := fmt.Sprintf("wpc_%s_%s", kind, hex.EncodeToString(h[:])[:12])

	key := family + "|" + name
	if _, ok := c.sets[key]; ok {
		return name
	}
	c.sets[key] = nftSetDef{
		Name:     name,
		Family:   family,
		ElemType: elemType,
		Flags:    append([]string(nil), flags...),
		Elements: normalized,
	}
	return name
}

func (c *nftRenderContext) ensureNamedSet(family string, name string, elemType string, flags []string) string {
	key := family + "|" + name
	if _, ok := c.sets[key]; ok {
		return name
	}
	c.sets[key] = nftSetDef{
		Name:     name,
		Family:   family,
		ElemType: elemType,
		Flags:    append([]string(nil), flags...),
		Elements: nil,
	}
	return name
}

func (c *nftRenderContext) renderSets(sb *strings.Builder) {
	if len(c.sets) == 0 {
		return
	}

	var defs []nftSetDef
	for _, def := range c.sets {
		defs = append(defs, def)
	}
	sort.Slice(defs, func(i, j int) bool {
		if defs[i].Family == defs[j].Family {
			return defs[i].Name < defs[j].Name
		}
		return defs[i].Family < defs[j].Family
	})

	for _, def := range defs {
		sb.WriteString(fmt.Sprintf("    set %s {\n", def.Name))
		sb.WriteString(fmt.Sprintf("        type %s\n", def.ElemType))
		if len(def.Flags) > 0 {
			sb.WriteString(fmt.Sprintf("        flags %s\n", strings.Join(def.Flags, ", ")))
		}
		if len(def.Elements) == 0 {
			sb.WriteString("        elements = { }\n")
		} else {
			sb.WriteString("        elements = {\n")
			for i, el := range def.Elements {
				if i < len(def.Elements)-1 {
					sb.WriteString(fmt.Sprintf("            %s,\n", el))
				} else {
					sb.WriteString(fmt.Sprintf("            %s\n", el))
				}
			}
			sb.WriteString("        }\n")
		}
		sb.WriteString("    }\n\n")
	}
}

func ifaceExpr(ifaces []string) string {
	if len(ifaces) == 0 {
		return ""
	}
	if len(ifaces) == 1 {
		return fmt.Sprintf("iifname \"%s\"", ifaces[0])
	}
	var quoted []string
	for _, iface := range ifaces {
		quoted = append(quoted, fmt.Sprintf("\"%s\"", iface))
	}
	return fmt.Sprintf("iifname { %s }", strings.Join(quoted, ", "))
}

// RenderNFTables generates a full nftables.conf based on the policy
func RenderNFTables(policy *types.Policy) (string, error) {
	var sb strings.Builder
	ctx := newNFTRenderContext()

	// Header
	sb.WriteString("# Generated by WPC (WirePolicy Compiler)\n")
	sb.WriteString("flush ruleset\n\n")

	// 1. Spec #2: IPv6 Leak Protection
	sb.WriteString("table ip6 wpc_safety {\n")
	sb.WriteString("    chain input { type filter hook input priority 0; policy drop; }\n")
	sb.WriteString("    chain forward { type filter hook forward priority 0; policy drop; }\n")
	if policy.Global.IPv6Mode == "block" {
		sb.WriteString("    chain output { type filter hook output priority 0; policy drop; }\n")
	}
	sb.WriteString("}\n\n")

	// 2. Spec #3 & #8: Raw Table for Defrag and Helper disabling
	sb.WriteString("table inet wpc_raw {\n")
	sb.WriteString("    chain prerouting {\n")
	sb.WriteString("        type filter hook prerouting priority -300; policy accept;\n")
	sb.WriteString("        ip defrag\n")
	sb.WriteString("        ip6 defrag\n")
	sb.WriteString("        ct helper set \"no-helper\"\n")
	sb.WriteString("    }\n")
	sb.WriteString("}\n\n")

	// 3. Main Filter Table
	sb.WriteString("table inet wpc_filter {\n")

	var renderedRules []string
	for _, rule := range policy.Rules {
		renderedRules = append(renderedRules, renderRule(ctx, rule)...)
	}

	var bogonRule4, bogonRule6 string
	if len(policy.Global.BogonInterfaces) > 0 {
		b4 := []string{
			"0.0.0.0/8",
			"10.0.0.0/8",
			"100.64.0.0/10",
			"127.0.0.0/8",
			"169.254.0.0/16",
			"172.16.0.0/12",
			"192.0.0.0/24",
			"192.0.2.0/24",
			"192.168.0.0/16",
			"198.18.0.0/15",
			"198.51.100.0/24",
			"203.0.113.0/24",
			"224.0.0.0/4",
			"240.0.0.0/4",
		}
		b6 := []string{
			"::/128",
			"::1/128",
			"64:ff9b::/96",
			"100::/64",
			"2001:db8::/32",
			"2001:10::/28",
			"fc00::/7",
			"fe80::/10",
			"ff00::/8",
		}
		face := ifaceExpr(policy.Global.BogonInterfaces)
		set4 := ctx.ensureSet("bogon4", "ip", "ipv4_addr", b4, []string{"interval"})
		set6 := ctx.ensureSet("bogon6", "ip6", "ipv6_addr", b6, []string{"interval"})
		bogonRule4 = fmt.Sprintf("        %s ip saddr @%s drop\n", face, set4)
		bogonRule6 = fmt.Sprintf("        %s ip6 saddr @%s drop\n", face, set6)
	}

	var geoRules []string
	if len(policy.Global.GeoBlockFeeds) > 0 {
		face := ifaceExpr(policy.Global.GeoBlockInterfaces)
		for _, feed := range policy.Global.GeoBlockFeeds {
			setName := GeoSetName(feed)
			elemType := "ipv4_addr"
			matchPrefix := "ip saddr"
			if feed.IPVersion == 6 {
				elemType = "ipv6_addr"
				matchPrefix = "ip6 saddr"
			}
			ctx.ensureNamedSet("inet", setName, elemType, []string{"interval"})
			prefix := ""
			if face != "" {
				prefix = face + " "
			}
			if policy.Global.GeoBlockMode == "allow" {
				geoRules = append(geoRules, fmt.Sprintf("        %s%s @%s accept\n", prefix, matchPrefix, setName))
			} else {
				geoRules = append(geoRules, fmt.Sprintf("        %s%s @%s drop\n", prefix, matchPrefix, setName))
			}
		}
		if policy.Global.GeoBlockMode == "allow" && face != "" {
			geoRules = append(geoRules, fmt.Sprintf("        %sip saddr 0.0.0.0/0 drop\n", face+" "))
			geoRules = append(geoRules, fmt.Sprintf("        %sip6 saddr ::/0 drop\n", face+" "))
		}
	}

	ctx.renderSets(&sb)

	// Input Chain
	sb.WriteString("    chain input {\n")
	sb.WriteString("        type filter hook input priority 0; policy drop;\n")
	
	// Basic safety
	sb.WriteString("        ct state invalid drop\n")
	sb.WriteString("        ct state established,related accept\n")
	sb.WriteString("        iifname \"lo\" accept\n")
	if bogonRule4 != "" {
		sb.WriteString(bogonRule4)
		sb.WriteString(bogonRule6)
	}
	for _, r := range geoRules {
		sb.WriteString(r)
	}

	if policy.Global.ProtectInterfaceOnly {
		sb.WriteString(fmt.Sprintf("        iifname != \"%s\" accept\n", policy.Global.Interface))
	}
	
	// Spec #14: PMTUD (ICMP)
	sb.WriteString("        ip protocol icmp icmp type { destination-unreachable, time-exceeded } accept\n")
	sb.WriteString("        ip6 nexthdr icmpv6 icmpv6 type { destination-unreachable, packet-too-big, time-exceeded, parameter-problem } accept\n")

	// Spec #1: Anti-Tunneling (Matryoshka)
	if !policy.Global.AllowTunneling {
		sb.WriteString("        meta l4proto { 41, 47, 50, 51 } drop\n")
	}

	// Custom Rules
	for _, line := range renderedRules {
		sb.WriteString(line)
	}

	sb.WriteString("        limit rate 5/minute burst 10 packets log prefix \"WPC_DROP_IN: \" level warning\n")
	sb.WriteString("    }\n")

	// Forward Chain
	sb.WriteString("    chain forward {\n")
	sb.WriteString("        type filter hook forward priority 0; policy drop;\n")
	sb.WriteString("    }\n")

	// Spec #13: Egress (Output) Chain
	sb.WriteString("    chain output {\n")
	sb.WriteString("        type filter hook output priority 0; ")
	if policy.Global.EgressPolicy == "block" {
		sb.WriteString("policy drop;\n")
		sb.WriteString("        ct state invalid drop\n")
		sb.WriteString("        ct state established,related accept\n")
		sb.WriteString("        oifname \"lo\" accept\n")
		// Allow DNS
		if len(policy.Global.DNSServers) > 0 {
			var dns4, dns6 []string
			for _, raw := range policy.Global.DNSServers {
				addr, err := netip.ParseAddr(raw)
				if err != nil {
					continue
				}
				if addr.Is6() {
					dns6 = append(dns6, addr.String())
				} else {
					dns4 = append(dns4, addr.String())
				}
			}
			if len(dns4) > 0 {
				dnsIPs := strings.Join(dns4, ", ")
				sb.WriteString(fmt.Sprintf("        udp dport 53 ip daddr { %s } accept\n", dnsIPs))
				sb.WriteString(fmt.Sprintf("        tcp dport 53 ip daddr { %s } accept\n", dnsIPs))
			}
			if len(dns6) > 0 {
				dnsIPs := strings.Join(dns6, ", ")
				sb.WriteString(fmt.Sprintf("        udp dport 53 ip6 daddr { %s } accept\n", dnsIPs))
				sb.WriteString(fmt.Sprintf("        tcp dport 53 ip6 daddr { %s } accept\n", dnsIPs))
			}
		}
		sb.WriteString("        limit rate 5/minute burst 10 packets log prefix \"WPC_DROP_OUT: \" level warning\n")
	} else {
		sb.WriteString("policy accept;\n")
	}
	sb.WriteString("    }\n")

	sb.WriteString("}\n")

	return sb.String(), nil
}

func splitPrefixes(prefixes []netip.Prefix) (v4 []string, v6 []string, hasAny bool) {
	for _, p := range prefixes {
		if p.Bits() == 0 {
			hasAny = true
			continue
		}
		if p.Addr().Is6() {
			v6 = append(v6, p.String())
		} else {
			v4 = append(v4, p.String())
		}
	}
	return v4, v6, hasAny
}

func addrExpr(ctx *nftRenderContext, kind string, family string, field string, elements []string) string {
	elements = normalizeElements(elements)
	const setThreshold = 16
	if len(elements) == 1 || len(elements) < setThreshold {
		return fmt.Sprintf("%s %s { %s }", family, field, strings.Join(elements, ", "))
	}
	elemType := "ipv4_addr"
	if family == "ip6" {
		elemType = "ipv6_addr"
	}
	setName := ctx.ensureSet(kind, family, elemType, elements, []string{"interval"})
	return fmt.Sprintf("%s %s @%s", family, field, setName)
}

func renderRule(ctx *nftRenderContext, rule types.Rule) []string {
	var lines []string

	src4, src6, srcAny := splitPrefixes(rule.SrcPrefixes)
	dst4, dst6, dstAny := splitPrefixes(rule.DstPrefixes)

	hasSrc := len(rule.SrcPrefixes) > 0
	hasDst := len(rule.DstPrefixes) > 0

	if !hasSrc && !hasDst {
		line := "        " + strings.Join(renderRuleParts(ctx, rule, "", "", "", ""), " ")
		if rule.Comment != "" {
			line += fmt.Sprintf(" comment \"%s\"", rule.Comment)
		}
		line += "\n"
		return append(lines, line)
	}

	if (!hasSrc || srcAny || len(src4) > 0) && (!hasDst || dstAny || len(dst4) > 0) {
		srcExpr := ""
		dstExpr := ""
		if hasSrc && !srcAny && len(src4) > 0 {
			srcExpr = addrExpr(ctx, "src", "ip", "saddr", src4)
		}
		if hasDst && !dstAny && len(dst4) > 0 {
			dstExpr = addrExpr(ctx, "dst", "ip", "daddr", dst4)
		}
		line := "        " + strings.Join(renderRuleParts(ctx, rule, "ip", srcExpr, "ip", dstExpr), " ")
		if rule.Comment != "" {
			line += fmt.Sprintf(" comment \"%s\"", rule.Comment)
		}
		line += "\n"
		lines = append(lines, line)
	}

	if (!hasSrc || srcAny || len(src6) > 0) && (!hasDst || dstAny || len(dst6) > 0) {
		srcExpr := ""
		dstExpr := ""
		if hasSrc && !srcAny && len(src6) > 0 {
			srcExpr = addrExpr(ctx, "src", "ip6", "saddr", src6)
		}
		if hasDst && !dstAny && len(dst6) > 0 {
			dstExpr = addrExpr(ctx, "dst", "ip6", "daddr", dst6)
		}
		line := "        " + strings.Join(renderRuleParts(ctx, rule, "ip6", srcExpr, "ip6", dstExpr), " ")
		if rule.Comment != "" {
			line += fmt.Sprintf(" comment \"%s\"", rule.Comment)
		}
		line += "\n"
		lines = append(lines, line)
	}

	return lines
}

func renderRuleParts(_ *nftRenderContext, rule types.Rule, _ string, srcExpr string, _ string, dstExpr string) []string {
	var parts []string

	if srcExpr != "" {
		parts = append(parts, srcExpr)
	}
	if dstExpr != "" {
		parts = append(parts, dstExpr)
	}

	if rule.Protocol != "any" {
		parts = append(parts, fmt.Sprintf("meta l4proto %s", rule.Protocol))
		if rule.Port != "any" {
			parts = append(parts, fmt.Sprintf("%s dport %s", rule.Protocol, rule.Port))
		}
	}

	parts = append(parts, rule.Action)
	return parts
}
