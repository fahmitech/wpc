package compiler

import (
	"fmt"
	"strings"

	"github.com/fahmitech/wpc/pkg/types"
)

// RenderNFTables generates a full nftables.conf based on the policy
func RenderNFTables(policy *types.Policy) (string, error) {
	var sb strings.Builder

	// Header
	sb.WriteString("# Generated by WPC (WirePolicy Compiler)\n")
	sb.WriteString("flush ruleset\n\n")

	// 1. Spec #2: IPv6 Leak Protection
	sb.WriteString("table ip6 wpc_safety {\n")
	sb.WriteString("    chain input { type filter hook input priority 0; policy drop; }\n")
	sb.WriteString("    chain forward { type filter hook forward priority 0; policy drop; }\n")
	if policy.Global.IPv6Mode == "block" {
		sb.WriteString("    chain output { type filter hook output priority 0; policy drop; }\n")
	}
	sb.WriteString("}\n\n")

	// 2. Spec #3 & #8: Raw Table for Defrag and Helper disabling
	sb.WriteString("table inet wpc_raw {\n")
	sb.WriteString("    chain prerouting {\n")
	sb.WriteString("        type filter hook prerouting priority -300; policy accept;\n")
	sb.WriteString("        ip defrag\n")
	sb.WriteString("        ip6 defrag\n")
	sb.WriteString("        ct helper set \"no-helper\"\n")
	sb.WriteString("    }\n")
	sb.WriteString("}\n\n")

	// 3. Main Filter Table
	sb.WriteString("table inet wpc_filter {\n")
	
	// Input Chain
	sb.WriteString("    chain input {\n")
	sb.WriteString("        type filter hook input priority 0; policy drop;\n")
	
	// Basic safety
	sb.WriteString("        ct state established accept\n")
	sb.WriteString("        meta l4proto { icmp, icmpv6 } ct state related accept\n")
	sb.WriteString("        iifname \"lo\" accept\n")
	
	// Spec #14: PMTUD (ICMP)
	sb.WriteString("        ip protocol icmp icmp type { destination-unreachable, time-exceeded } accept\n")
	sb.WriteString("        ip6 nexthdr icmpv6 icmpv6 type { destination-unreachable, packet-too-big, time-exceeded, parameter-problem } accept\n")

	// Spec #1: Anti-Tunneling (Matryoshka)
	if !policy.Global.AllowTunneling {
		sb.WriteString("        meta l4proto { 41, 47, 50, 51 } drop\n")
	}

	// Custom Rules
	for _, rule := range policy.Rules {
		sb.WriteString(renderRule(rule))
	}

	sb.WriteString("    }\n")

	// Forward Chain
	sb.WriteString("    chain forward {\n")
	sb.WriteString("        type filter hook forward priority 0; policy drop;\n")
	sb.WriteString("    }\n")

	// Spec #13: Egress (Output) Chain
	sb.WriteString("    chain output {\n")
	sb.WriteString("        type filter hook output priority 0; ")
	if policy.Global.EgressPolicy == "block" {
		sb.WriteString("policy drop;\n")
		// Allow established
		sb.WriteString("        ct state established,related accept\n")
		// Allow DNS
		if len(policy.Global.DNSServers) > 0 {
			dnsIps := strings.Join(policy.Global.DNSServers, ", ")
			sb.WriteString(fmt.Sprintf("        udp dport 53 ip daddr { %s } accept\n", dnsIps))
		}
	} else {
		sb.WriteString("policy accept;\n")
	}
	sb.WriteString("    }\n")

	sb.WriteString("}\n")

	return sb.String(), nil
}

func renderRule(rule types.Rule) string {
	var parts []string
	
	// Sources
	if len(rule.SrcPrefixes) > 0 {
		var ip4s, ip6s []string
		for _, p := range rule.SrcPrefixes {
			if p.Addr().Is6() {
				ip6s = append(ip6s, p.String())
			} else {
				ip4s = append(ip4s, p.String())
			}
		}
		if len(ip4s) > 0 {
			parts = append(parts, fmt.Sprintf("ip saddr { %s }", strings.Join(ip4s, ", ")))
		}
		if len(ip6s) > 0 {
			parts = append(parts, fmt.Sprintf("ip6 saddr { %s }", strings.Join(ip6s, ", ")))
		}
	}

	// Destinations
	if len(rule.DstPrefixes) > 0 {
		var ip4s, ip6s []string
		for _, p := range rule.DstPrefixes {
			if p.Addr().Is6() {
				ip6s = append(ip6s, p.String())
			} else {
				ip4s = append(ip4s, p.String())
			}
		}
		if len(ip4s) > 0 {
			parts = append(parts, fmt.Sprintf("ip daddr { %s }", strings.Join(ip4s, ", ")))
		}
		if len(ip6s) > 0 {
			parts = append(parts, fmt.Sprintf("ip6 daddr { %s }", strings.Join(ip6s, ", ")))
		}
	}

	// Protocol and Port
	if rule.Protocol != "any" {
		parts = append(parts, fmt.Sprintf("meta l4proto %s", rule.Protocol))
		if rule.Port != "any" {
			if strings.Contains(rule.Port, "-") {
				parts = append(parts, fmt.Sprintf("%s dport %s", rule.Protocol, rule.Port))
			} else {
				parts = append(parts, fmt.Sprintf("%s dport %s", rule.Protocol, rule.Port))
			}
		}
	}

	// Action
	parts = append(parts, rule.Action)

	// Comment
	line := "        " + strings.Join(parts, " ")
	if rule.Comment != "" {
		line += fmt.Sprintf(" comment \"%s\"", rule.Comment)
	}
	line += "\n"

	return line
}
